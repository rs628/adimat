% Generated by ADiMat 0.6.0-4867
% Copyright 2009-2013 Johannes Willkomm, Fachgebiet Scientific Computing,
% TU Darmstadt, 64289 Darmstadt, Germany
% Copyright 2001-2008 Andre Vehreschild, Institute for Scientific Computing,
% RWTH Aachen University, 52056 Aachen, Germany.
% Visit us on the web at http://www.adimat.de
% Report bugs to adimat-users@lists.sc.informatik.tu-darmstadt.de
%
%
%                             DISCLAIMER
%
% ADiMat was prepared as part of an employment at the Institute
% for Scientific Computing, RWTH Aachen University, Germany and is
% provided AS IS. NEITHER THE AUTHOR(S), THE GOVERNMENT OF THE FEDERAL
% REPUBLIC OF GERMANY NOR ANY AGENCY THEREOF, NOR THE RWTH AACHEN UNIVERSITY,
% INCLUDING ANY OF THEIR EMPLOYEES OR OFFICERS, MAKES ANY WARRANTY,
% EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY
% FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF ANY INFORMATION OR
% PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE
% PRIVATELY OWNED RIGHTS.
%
% Global flags were:
% FORWARDMODE -- Apply the forward mode to the files.
% NOOPEROPTIM -- Do not use optimized operators. I.e.:
%		 g_a*b*g_c -/-> mtimes3(g_a, b, g_c)
% NOLOCALCSE  -- Do not use local common subexpression elimination when
%		 canonicalizing the code.
% NOGLOBALCSE -- Prevents the application of global common subexpression
%		 elimination after canonicalizing the code.
% NOPRESCALARFOLDING -- Switch off folding of scalar constants before
%		 augmentation.
% NOPOSTSCALARFOLDING -- Switch off folding of scalar constants after
%		 augmentation.
% NOCONSTFOLDMULT0 -- Switch off folding of product with one factor
%		 being zero: b*0=0.
% FUNCMODE    -- Inputfile is a function (This flag can not be set explicitly).
% NOTMPCLEAR  -- Suppress generation of clear g_* instructions.
% UNBOUND_ERROR	-- Stop with error if unbound identifiers found (default).
% VERBOSITYLEVEL=4

% function [Pk u] = mk_householder_elim_vec_lapack(a, n)
%
% input: column vector a
% result: Householder matrix H = I - sigma u u' 
%
% This computes H in LAPACK style [1], and thus also as Matlab and
% Octave do.
%
% [1] Lehoucq, Richard B, "The computation of elementary unitary matrices", 1996
%
% Copyright (C) 2013 Johannes Willkomm
%
function [g_Pk, Pk, g_u, u]= g_mk_householder_elim_vec_lapack(g_a, a, n)
   tolZ= eps; 
   
   assert(iscolumn(a)); 
   
   g_tmp_a_00000= g_a(1);
   tmp_a_00000= a(1);
   g_tmp_mk_householder_elim_vec_lapack_00000= g_tmp_a_00000.* 0;
   tmp_mk_householder_elim_vec_lapack_00000= tmp_a_00000.* 0;
   g_Pk= g_tmp_mk_householder_elim_vec_lapack_00000+ g_zeros(size(eye(n)));
   Pk= eye(n)+ tmp_mk_householder_elim_vec_lapack_00000; 
   
   k= length(a); 
   
   g_na= g_adimat_norm2(g_a, a, 2);
   na= norm(a); 
   
   if ~(k== 1&& isreal(a))&& na~= 0
      g_u= g_a;
      u= a; 
      
      na_rest= norm(a(2: end)); 
      
      if na> tolZ&& na_rest~= 0
         sa1= sign(real(a(1))); 
         if sa1== 0, sa1= 1; end
         
         g_nu= sa1.* g_na;
         nu= sa1.* na; 
         
         g_tmp_u_00000= g_u(1);
         tmp_u_00000= u(1);
         g_u(1)= g_tmp_u_00000+ g_nu;
         u(1)= tmp_u_00000+ nu; 
         g_tmp_a_00001= g_a(1);
         tmp_a_00001= a(1);
         g_tmp_mk_householder_elim_vec_lapack_00001= g_tmp_a_00001+ g_nu;
         tmp_mk_householder_elim_vec_lapack_00001= tmp_a_00001+ nu;
         g_tmp_mk_householder_elim_vec_lapack_00005= (g_u.* tmp_mk_householder_elim_vec_lapack_00001- u.* g_tmp_mk_householder_elim_vec_lapack_00001)./ tmp_mk_householder_elim_vec_lapack_00001.^ 2;
         tmp_mk_householder_elim_vec_lapack_00005= u./ tmp_mk_householder_elim_vec_lapack_00001; 
         
         % Update detected: u= some_expression(u,...)
         g_u= g_tmp_mk_householder_elim_vec_lapack_00005;
         u= tmp_mk_householder_elim_vec_lapack_00005;
         g_tmp_a_00002= g_a(1);
         tmp_a_00002= a(1);
         g_tmp_mk_householder_elim_vec_lapack_00002= g_tmp_a_00002+ g_nu;
         tmp_mk_householder_elim_vec_lapack_00002= tmp_a_00002+ nu;
         g_sigma= (g_tmp_mk_householder_elim_vec_lapack_00002.* nu- tmp_mk_householder_elim_vec_lapack_00002.* g_nu)./ nu.^ 2;
         sigma= tmp_mk_householder_elim_vec_lapack_00002./ nu; 
         
         g_tmp_mk_householder_elim_vec_lapack_00003= g_sigma.* u+ sigma.* g_u;
         tmp_mk_householder_elim_vec_lapack_00003= sigma.* u;
         g_tmp_mk_householder_elim_vec_lapack_00004= g_tmp_mk_householder_elim_vec_lapack_00003* u' + tmp_mk_householder_elim_vec_lapack_00003* g_u' ;
         tmp_mk_householder_elim_vec_lapack_00004= tmp_mk_householder_elim_vec_lapack_00003* u' ;
         g_Pksub= -g_tmp_mk_householder_elim_vec_lapack_00004+ g_zeros(size(eye(k)));
         Pksub= eye(k)- tmp_mk_householder_elim_vec_lapack_00004; 
         
         g_Pk(n- k+ 1: end, n- k+ 1: end)= g_Pksub;
         Pk(n- k+ 1: end, n- k+ 1: end)= Pksub; 
         
      end
   end
   
end

% $Id: mk_householder_elim_vec_lapack.m 4801 2014-10-08 12:28:59Z willkomm $
