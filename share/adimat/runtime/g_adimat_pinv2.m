% Generated by ADiMat 0.6.0-4867
% Copyright 2009-2013 Johannes Willkomm, Fachgebiet Scientific Computing,
% TU Darmstadt, 64289 Darmstadt, Germany
% Copyright 2001-2008 Andre Vehreschild, Institute for Scientific Computing,
% RWTH Aachen University, 52056 Aachen, Germany.
% Visit us on the web at http://www.adimat.de
% Report bugs to adimat-users@lists.sc.informatik.tu-darmstadt.de
%
%
%                             DISCLAIMER
%
% ADiMat was prepared as part of an employment at the Institute
% for Scientific Computing, RWTH Aachen University, Germany and is
% provided AS IS. NEITHER THE AUTHOR(S), THE GOVERNMENT OF THE FEDERAL
% REPUBLIC OF GERMANY NOR ANY AGENCY THEREOF, NOR THE RWTH AACHEN UNIVERSITY,
% INCLUDING ANY OF THEIR EMPLOYEES OR OFFICERS, MAKES ANY WARRANTY,
% EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY
% FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF ANY INFORMATION OR
% PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE
% PRIVATELY OWNED RIGHTS.
%
% Global flags were:
% FORWARDMODE -- Apply the forward mode to the files.
% NOOPEROPTIM -- Do not use optimized operators. I.e.:
%		 g_a*b*g_c -/-> mtimes3(g_a, b, g_c)
% NOLOCALCSE  -- Do not use local common subexpression elimination when
%		 canonicalizing the code.
% NOGLOBALCSE -- Prevents the application of global common subexpression
%		 elimination after canonicalizing the code.
% NOPRESCALARFOLDING -- Switch off folding of scalar constants before
%		 augmentation.
% NOPOSTSCALARFOLDING -- Switch off folding of scalar constants after
%		 augmentation.
% NOCONSTFOLDMULT0 -- Switch off folding of product with one factor
%		 being zero: b*0=0.
% FUNCMODE    -- Inputfile is a function (This flag can not be set explicitly).
% NOTMPCLEAR  -- Suppress generation of clear g_* instructions.
% UNBOUND_ERROR	-- Stop with error if unbound identifiers found (default).
% VERBOSITYLEVEL=4
% AD_IVARS= A
% AD_DVARS= z

function [g_z, z]= g_adimat_pinv2(g_A, A, tol)
   if isreal(A)
      [tmp_svd_00000, U, tmp_svd_00001, S, tmp_svd_00002, V]= adimat_g_svd(g_A, A); 
      g_U= tmp_svd_00000; g_S= tmp_svd_00001; g_V= tmp_svd_00002; 
   else 
      [g_U, U, g_S, S, g_V, V]= g_adimat_svd(g_A, A); 
   end
   [g_d, d]= g_adimat_safediag(g_S, S); 
   nign= d> tol; 
   g_tmp_d_00000= g_d(nign);
   tmp_d_00000= d(nign);
   g_d(nign)= (-1.* g_tmp_d_00000)./ tmp_d_00000.^ 2;
   d(nign)= 1./ tmp_d_00000; 
   d(~nign)= 0; 
   g_d(~nign)= g_zeros(size(d(~nign)));
   g_T= g_S;
   T= S; 
   for i= 1: length(d)
      g_tmp_d_00001= g_d(i);
      tmp_d_00001= d(i);
      g_T(i, i)= g_tmp_d_00001;
      T(i, i)= tmp_d_00001; 
   end
   g_z= g_V* T.' * U' + V* g_T.' * U' + V* T.' * g_U' ;
   z= V* T.' * U' ; 
end

