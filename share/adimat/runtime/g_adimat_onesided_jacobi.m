% Generated by ADiMat 0.6.0-4867
% Copyright 2009-2013 Johannes Willkomm, Fachgebiet Scientific Computing,
% TU Darmstadt, 64289 Darmstadt, Germany
% Copyright 2001-2008 Andre Vehreschild, Institute for Scientific Computing,
% RWTH Aachen University, 52056 Aachen, Germany.
% Visit us on the web at http://www.adimat.de
% Report bugs to adimat-users@lists.sc.informatik.tu-darmstadt.de
%
%
%                             DISCLAIMER
%
% ADiMat was prepared as part of an employment at the Institute
% for Scientific Computing, RWTH Aachen University, Germany and is
% provided AS IS. NEITHER THE AUTHOR(S), THE GOVERNMENT OF THE FEDERAL
% REPUBLIC OF GERMANY NOR ANY AGENCY THEREOF, NOR THE RWTH AACHEN UNIVERSITY,
% INCLUDING ANY OF THEIR EMPLOYEES OR OFFICERS, MAKES ANY WARRANTY,
% EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY
% FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF ANY INFORMATION OR
% PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE
% PRIVATELY OWNED RIGHTS.
%
% Global flags were:
% FORWARDMODE -- Apply the forward mode to the files.
% NOOPEROPTIM -- Do not use optimized operators. I.e.:
%		 g_a*b*g_c -/-> mtimes3(g_a, b, g_c)
% NOLOCALCSE  -- Do not use local common subexpression elimination when
%		 canonicalizing the code.
% NOGLOBALCSE -- Prevents the application of global common subexpression
%		 elimination after canonicalizing the code.
% NOPRESCALARFOLDING -- Switch off folding of scalar constants before
%		 augmentation.
% NOPOSTSCALARFOLDING -- Switch off folding of scalar constants after
%		 augmentation.
% NOCONSTFOLDMULT0 -- Switch off folding of product with one factor
%		 being zero: b*0=0.
% FUNCMODE    -- Inputfile is a function (This flag can not be set explicitly).
% NOTMPCLEAR  -- Suppress generation of clear g_* instructions.
% UNBOUND_ERROR	-- Stop with error if unbound identifiers found (default).
% VERBOSITYLEVEL=4

function [g_z, z, g_A, A, g_V, V, nt]= g_adimat_onesided_jacobi(g_A, A, nA1)
   
   nargoutmapper_00001= [0, 1, 0, 2, 0, 3, 4];
   [m, n]= size(A); 
   nt= n; % matrix is tall, m > n
   
   slimit= max(n./ 4, 6).* 10; 
   
   if nargoutmapper_00001(nargout)> 2
      V= eye(n, n); 
      g_V= g_zeros(size(V));
   end
   
   z= zeros(nt, 1); 
   
   g_z= g_zeros(size(z));
   if nt== 1
      g_z(1)= g_A' * A+ A' * g_A;
      z(1)= A' * A; 
   end
   
   tol= eps; 
   
   noRotationHere= 0; 
   
   scount= 0; 
   rcount= nt.* (nt- 1)./ 2; 
   
   tmp_adimat_onesided_jacobi_00000= scount<= slimit;
   tmp_adimat_onesided_jacobi_00001= rcount> 0;
   while tmp_adimat_onesided_jacobi_00000&& tmp_adimat_onesided_jacobi_00001
      rcount= nt.* (nt- 1)./ 2; 
      tmp_adimat_onesided_jacobi_00002= nt- 1;
      for j= 1: tmp_adimat_onesided_jacobi_00002
         tmp_adimat_onesided_jacobi_00003= j+ 1;
         for k= tmp_adimat_onesided_jacobi_00003: nt
            noRotationHere= 0; 
            
            g_tmp_A_00000= g_A(: , j);
            tmp_A_00000= A(: , j);
            g_tmp_A_00001= g_A(: , k);
            tmp_A_00001= A(: , k);
            g_p= g_tmp_A_00000' * tmp_A_00001+ tmp_A_00000' * g_tmp_A_00001;
            p= tmp_A_00000' * tmp_A_00001; 
            g_tmp_A_00002= g_A(: , j);
            tmp_A_00002= A(: , j);
            g_tmp_A_00003= g_A(: , j);
            tmp_A_00003= A(: , j);
            g_q= g_tmp_A_00002' * tmp_A_00003+ tmp_A_00002' * g_tmp_A_00003;
            q= tmp_A_00002' * tmp_A_00003; 
            g_tmp_A_00004= g_A(: , k);
            tmp_A_00004= A(: , k);
            g_tmp_A_00005= g_A(: , k);
            tmp_A_00005= A(: , k);
            g_r= g_tmp_A_00004' * tmp_A_00005+ tmp_A_00004' * g_tmp_A_00005;
            r= tmp_A_00004' * tmp_A_00005; 
            g_z(j)= g_q;
            z(j)= q; 
            g_z(k)= g_r;
            z(k)= r; 
            
            if q< r
               g_tmp_adimat_onesided_jacobi_00004= (g_q.* r- q.* g_r)./ r.^ 2;
               tmp_adimat_onesided_jacobi_00004= q./ r;
               g_q= g_tmp_adimat_onesided_jacobi_00004+ g_zeros(1);
               q= tmp_adimat_onesided_jacobi_00004- 1; 
               g_tmp_adimat_onesided_jacobi_00021= (g_p.* r- p.* g_r)./ r.^ 2;
               tmp_adimat_onesided_jacobi_00021= p./ r; 
               % Update detected: p= some_expression(p,...)
               g_p= g_tmp_adimat_onesided_jacobi_00021;
               p= tmp_adimat_onesided_jacobi_00021;
               g_tmp_conj_00001= call(@conj, g_p);
               tmp_conj_00001= conj(p);
               g_tmp_adimat_onesided_jacobi_00005= 4.* g_tmp_conj_00001.* p+ 4.* tmp_conj_00001.* g_p;
               tmp_adimat_onesided_jacobi_00005= 4.* tmp_conj_00001.* p;
               g_tmp_adimat_onesided_jacobi_00006= g_q.* q+ q.* g_q;
               tmp_adimat_onesided_jacobi_00006= q.* q;
               g_tmp_adimat_onesided_jacobi_00007= g_tmp_adimat_onesided_jacobi_00005+ g_tmp_adimat_onesided_jacobi_00006;
               tmp_adimat_onesided_jacobi_00007= tmp_adimat_onesided_jacobi_00005+ tmp_adimat_onesided_jacobi_00006;
               vt= sqrt(tmp_adimat_onesided_jacobi_00007); 
               g_vt= g_tmp_adimat_onesided_jacobi_00007./ (2.* vt);
               g_tmp_adimat_onesided_jacobi_00008= (g_q.* vt- q.* g_vt)./ vt.^ 2;
               tmp_adimat_onesided_jacobi_00008= q./ vt;
               g_tmp_adimat_onesided_jacobi_00009= -g_tmp_adimat_onesided_jacobi_00008+ g_zeros(1);
               tmp_adimat_onesided_jacobi_00009= 1- tmp_adimat_onesided_jacobi_00008;
               g_tmp_adimat_onesided_jacobi_00010= 0.5.* g_tmp_adimat_onesided_jacobi_00009;
               tmp_adimat_onesided_jacobi_00010= 0.5.* tmp_adimat_onesided_jacobi_00009;
               s= sqrt(tmp_adimat_onesided_jacobi_00010); 
               g_s= g_tmp_adimat_onesided_jacobi_00010./ (2.* s);
               if p< 0
                  g_tmp_adimat_onesided_jacobi_00022= -g_s;
                  tmp_adimat_onesided_jacobi_00022= -s; 
                  % Update detected: s= some_expression(s,...)
                  g_s= g_tmp_adimat_onesided_jacobi_00022;
                  s= tmp_adimat_onesided_jacobi_00022;
               end
               g_tmp_adimat_onesided_jacobi_00011= g_vt.* s+ vt.* g_s;
               tmp_adimat_onesided_jacobi_00011= vt.* s;
               g_c= (g_p.* tmp_adimat_onesided_jacobi_00011- p.* g_tmp_adimat_onesided_jacobi_00011)./ tmp_adimat_onesided_jacobi_00011.^ 2;
               c= p./ tmp_adimat_onesided_jacobi_00011; 
            elseif q.* r<= eps.^ 2.* nA1
               noRotationHere= 1; 
            elseif (p./ q)' .* p./ r<= eps.^ 2.* nA1
               noRotationHere= 1; 
            else 
               g_tmp_adimat_onesided_jacobi_00012= (g_r.* q- r.* g_q)./ q.^ 2;
               tmp_adimat_onesided_jacobi_00012= r./ q;
               g_r= -g_tmp_adimat_onesided_jacobi_00012+ g_zeros(1);
               r= 1- tmp_adimat_onesided_jacobi_00012; 
               g_tmp_adimat_onesided_jacobi_00023= (g_p.* q- p.* g_q)./ q.^ 2;
               tmp_adimat_onesided_jacobi_00023= p./ q; 
               % Update detected: p= some_expression(p,...)
               g_p= g_tmp_adimat_onesided_jacobi_00023;
               p= tmp_adimat_onesided_jacobi_00023;
               g_tmp_conj_00002= call(@conj, g_p);
               tmp_conj_00002= conj(p);
               g_tmp_adimat_onesided_jacobi_00013= 4.* g_tmp_conj_00002.* p+ 4.* tmp_conj_00002.* g_p;
               tmp_adimat_onesided_jacobi_00013= 4.* tmp_conj_00002.* p;
               g_tmp_adimat_onesided_jacobi_00014= g_r.* r+ r.* g_r;
               tmp_adimat_onesided_jacobi_00014= r.* r;
               g_tmp_adimat_onesided_jacobi_00015= g_tmp_adimat_onesided_jacobi_00013+ g_tmp_adimat_onesided_jacobi_00014;
               tmp_adimat_onesided_jacobi_00015= tmp_adimat_onesided_jacobi_00013+ tmp_adimat_onesided_jacobi_00014;
               vt= sqrt(tmp_adimat_onesided_jacobi_00015); 
               g_vt= g_tmp_adimat_onesided_jacobi_00015./ (2.* vt);
               g_tmp_adimat_onesided_jacobi_00016= (g_r.* vt- r.* g_vt)./ vt.^ 2;
               tmp_adimat_onesided_jacobi_00016= r./ vt;
               g_tmp_adimat_onesided_jacobi_00017= g_tmp_adimat_onesided_jacobi_00016+ g_zeros(1);
               tmp_adimat_onesided_jacobi_00017= 1+ tmp_adimat_onesided_jacobi_00016;
               g_tmp_adimat_onesided_jacobi_00018= 0.5.* g_tmp_adimat_onesided_jacobi_00017;
               tmp_adimat_onesided_jacobi_00018= 0.5.* tmp_adimat_onesided_jacobi_00017;
               c= sqrt(tmp_adimat_onesided_jacobi_00018); 
               g_c= g_tmp_adimat_onesided_jacobi_00018./ (2.* c);
               g_tmp_adimat_onesided_jacobi_00019= g_vt.* c+ vt.* g_c;
               tmp_adimat_onesided_jacobi_00019= vt.* c;
               g_s= (g_p.* tmp_adimat_onesided_jacobi_00019- p.* g_tmp_adimat_onesided_jacobi_00019)./ tmp_adimat_onesided_jacobi_00019.^ 2;
               s= p./ tmp_adimat_onesided_jacobi_00019; 
            end
            
            if noRotationHere== 0
               [g_G, G]= g_mk_givens(g_c, c, g_s, s, n, j, k); 
               %          assert(adimat_isunitary(G));
               g_tmp_adimat_onesided_jacobi_00024= g_A* G+ A* g_G;
               tmp_adimat_onesided_jacobi_00024= A* G; 
               % Update detected: A= some_expression(A,...)
               g_A= g_tmp_adimat_onesided_jacobi_00024;
               A= tmp_adimat_onesided_jacobi_00024;
               if nargoutmapper_00001(nargout)> 2
                  g_tmp_adimat_onesided_jacobi_00020= g_V* G+ V* g_G;
                  tmp_adimat_onesided_jacobi_00020= V* G;
                  g_V= call(@full, g_tmp_adimat_onesided_jacobi_00020);
                  V= full(tmp_adimat_onesided_jacobi_00020); 
               end
            else 
               tmp_adimat_onesided_jacobi_00025= rcount- 1; 
               % Update detected: rcount= some_expression(rcount,...)
               rcount= tmp_adimat_onesided_jacobi_00025;
            end
            
            tmp_adimat_onesided_jacobi_00003= j+ 1;
         end
         tmp_adimat_onesided_jacobi_00002= nt- 1;
      end
      %    fprintf(1, 'end of sweeep %d, number of rotations: %d\n', scount, rcount);
      
      if nt> 1
         if z(nt)./ (z(1)+ tol)<= tol
            tmp_adimat_onesided_jacobi_00026= nt- 1; 
            % Update detected: nt= some_expression(nt,...)
            nt= tmp_adimat_onesided_jacobi_00026;
         end
      end
      
      tmp_adimat_onesided_jacobi_00027= scount+ 1; 
      
      % Update detected: scount= some_expression(scount,...)
      scount= tmp_adimat_onesided_jacobi_00027;
      tmp_adimat_onesided_jacobi_00000= scount<= slimit;
      tmp_adimat_onesided_jacobi_00001= rcount> 0;
   end
   
   if nargoutmapper_00001(nargout)> 1%    assert(adimat_isunitary(V));
   end
   
   if scount> slimit
      error('adimat:onesided_jacobi:too_many_sweeps', 'Too many sweeps (%d) in one-sided Jacobi scheme', scount); 
   end
   
end

% $Id: adimat_onesided_jacobi.m 4162 2014-05-12 07:34:49Z willkomm $
