% Generated by ADiMat 0.6.0-4867
% © 2001-2008 Andre Vehreschild <vehreschild@sc.rwth-aachen.de>
% © 2009-2013 Johannes Willkomm <johannes.willkomm@sc.tu-darmstadt.de>
% RWTH Aachen University, 52056 Aachen, Germany
% TU Darmstadt, 64289 Darmstadt, Germany
% Visit us on the web at http://www.adimat.de/
% Report bugs to adimat-users@lists.sc.informatik.tu-darmstadt.de
%
%                             DISCLAIMER
% 
% ADiMat was prepared as part of an employment at the Institute for Scientific Computing,
% RWTH Aachen University, Germany and at the Institute for Scientific Computing,
% TU Darmstadt, Germany and is provided AS IS. 
% NEITHER THE AUTHOR(S), THE GOVERNMENT OF THE FEDERAL REPUBLIC OF GERMANY
% NOR ANY AGENCY THEREOF, NOR THE RWTH AACHEN UNIVERSITY, NOT THE TU DARMSTADT,
% INCLUDING ANY OF THEIR EMPLOYEES OR OFFICERS, MAKES ANY WARRANTY, EXPRESS OR IMPLIED,
% OR ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS,
% OR USEFULNESS OF ANY INFORMATION OR PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE
% WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS.
%
% Flags: FORWARDMODE,  NOOPEROPTIM,
%   NOLOCALCSE,  NOGLOBALCSE,  NOPRESCALARFOLDING,
%   NOPOSTSCALARFOLDING,  NOCONSTFOLDMULT0,  FUNCMODE,
%   NOTMPCLEAR,  DUMP_XML,  PARSE_ONLY,
%   UNBOUND_ERROR
%
% Parameters:
%  - dependents=U
%  - independents=A
%  - inputEncoding=ISO-8859-1
%  - output-mode: plain
%  - output-file: ad_out/d_adimat_chol.m
%  - output-file-prefix: 
%  - output-directory: ad_out
% Generated by ADiMat 0.6.0-4867
% © 2001-2008 Andre Vehreschild <vehreschild@sc.rwth-aachen.de>
% © 2009-2013 Johannes Willkomm <johannes.willkomm@sc.tu-darmstadt.de>
% RWTH Aachen University, 52056 Aachen, Germany
% TU Darmstadt, 64289 Darmstadt, Germany
% Visit us on the web at http://www.adimat.de/
% Report bugs to adimat-users@lists.sc.informatik.tu-darmstadt.de
%
%                             DISCLAIMER
% 
% ADiMat was prepared as part of an employment at the Institute for Scientific Computing,
% RWTH Aachen University, Germany and at the Institute for Scientific Computing,
% TU Darmstadt, Germany and is provided AS IS. 
% NEITHER THE AUTHOR(S), THE GOVERNMENT OF THE FEDERAL REPUBLIC OF GERMANY
% NOR ANY AGENCY THEREOF, NOR THE RWTH AACHEN UNIVERSITY, NOT THE TU DARMSTADT,
% INCLUDING ANY OF THEIR EMPLOYEES OR OFFICERS, MAKES ANY WARRANTY, EXPRESS OR IMPLIED,
% OR ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS,
% OR USEFULNESS OF ANY INFORMATION OR PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE
% WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS.
%
% Flags: FORWARDMODE,  NOOPEROPTIM,
%   NOLOCALCSE,  NOGLOBALCSE,  NOPRESCALARFOLDING,
%   NOPOSTSCALARFOLDING,  NOCONSTFOLDMULT0,  FUNCMODE,
%   NOTMPCLEAR,  DUMP_XML,  PARSE_ONLY,
%   UNBOUND_ERROR
%
% Parameters:
%  - dependents=U
%  - independents=A
%  - inputEncoding=ISO-8859-1
%  - output-mode: plain
%  - output-file: ad_out/d_adimat_chol.m
%  - output-file-prefix: 
%  - output-directory: ad_out
%
% Functions in this file: d_adimat_chol
%

function [d_U U] = d_adimat_chol(d_A, A)
% CHOLESKY_FACTOR computes the Cholesky factor of a matrix.
%
% Given a symmetric positive definite matrix A, this function computes the
% upper triangular matrix U such that U'*U = A. Since we are trying to
% mimic a Fortran program, this Matlab implementation works on a scalar
% level, avoiding all vector-like operations.
%
% From an algorithmic point of view, this function produces the output U
% from using the upper triangular part of the input A. The lower tringular
% part of A is never used. That is, using automatic or numerical
% differentiation, the derivatives wrt all entries of the lower triangular
% part will be zero. 
% Author: D. Fabregat Traver, RWTH Aachen University
% Date: 03/08/12
% History: 
% 1) Comment added by Martin Buecker, 03/19/12
% 2) Re-vectorized, second parameter added by Johannes Willkomm, 06/17/12
   tmpda2 = [];
   tmpda1 = [];
   k = [];
   tmpca1 = [];
   d_tmpca1 = d_zeros(tmpca1);
   n = size(A, 1);
   for i=1 : n
      [tmpada1 A(i, i)] = adimat_diff_sqrt(adimat_opdiff_subsref(d_A, struct('type', '()', 'subs', {{i i}})), A(i, i));
      d_A = adimat_opdiff_subsasgn(d_A, struct('type', {'()'}, 'subs', {{i i}}), tmpada1);
      tmpda2 = i + 1;
      tmpda1 = i + 1;
      d_A = adimat_opdiff_subsasgn(d_A, struct('type', {'()'}, 'subs', {{i tmpda1 : n}}), adimat_opdiff_ediv(adimat_opdiff_subsref(d_A, struct('type', '()', 'subs', {{i tmpda2 : n}})), A(i, tmpda2 : n), adimat_opdiff_subsref(d_A, struct('type', '()', 'subs', {{i i}})), A(i, i)));
      A(i, tmpda1 : n) = A(i, tmpda2 : n) ./ A(i, i);
      for j=i+1 : n
         k = i+1 : j;
         d_tmpca1 = adimat_opdiff_emult(adimat_opdiff_subsref(d_A, struct('type', '()', 'subs', {{i k}})), A(i, k), adimat_opdiff_subsref(d_A, struct('type', '()', 'subs', {{i j}})), A(i, j));
         tmpca1 = A(i, k) .* A(i, j);
         d_A = adimat_opdiff_subsasgn(d_A, struct('type', {'()'}, 'subs', {{k j}}), adimat_opdiff_sum(adimat_opdiff_etrans(adimat_opdiff_subsref(d_A, struct('type', '()', 'subs', {{k j}})), A(k, j)), -d_tmpca1));
         A(k, j) = A(k, j).' - tmpca1;
      end
   end
   [d_U U] = adimat_diff_triu(d_A, A);
end
% $Id: adimat_chol.m 3739 2013-06-12 16:49:42Z willkomm $
