% Generated by ADiMat 0.6.0-4867
% Copyright 2009-2013 Johannes Willkomm, Fachgebiet Scientific Computing,
% TU Darmstadt, 64289 Darmstadt, Germany
% Copyright 2001-2008 Andre Vehreschild, Institute for Scientific Computing,
% RWTH Aachen University, 52056 Aachen, Germany.
% Visit us on the web at http://www.adimat.de
% Report bugs to adimat-users@lists.sc.informatik.tu-darmstadt.de
%
%
%                             DISCLAIMER
%
% ADiMat was prepared as part of an employment at the Institute
% for Scientific Computing, RWTH Aachen University, Germany and is
% provided AS IS. NEITHER THE AUTHOR(S), THE GOVERNMENT OF THE FEDERAL
% REPUBLIC OF GERMANY NOR ANY AGENCY THEREOF, NOR THE RWTH AACHEN UNIVERSITY,
% INCLUDING ANY OF THEIR EMPLOYEES OR OFFICERS, MAKES ANY WARRANTY,
% EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY
% FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF ANY INFORMATION OR
% PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE
% PRIVATELY OWNED RIGHTS.
%
% Global flags were:
% FORWARDMODE -- Apply the forward mode to the files.
% NOOPEROPTIM -- Do not use optimized operators. I.e.:
%		 g_a*b*g_c -/-> mtimes3(g_a, b, g_c)
% NOLOCALCSE  -- Do not use local common subexpression elimination when
%		 canonicalizing the code.
% NOGLOBALCSE -- Prevents the application of global common subexpression
%		 elimination after canonicalizing the code.
% NOPRESCALARFOLDING -- Switch off folding of scalar constants before
%		 augmentation.
% NOPOSTSCALARFOLDING -- Switch off folding of scalar constants after
%		 augmentation.
% NOCONSTFOLDMULT0 -- Switch off folding of product with one factor
%		 being zero: b*0=0.
% FUNCMODE    -- Inputfile is a function (This flag can not be set explicitly).
% NOTMPCLEAR  -- Suppress generation of clear g_* instructions.
% UNBOUND_ERROR	-- Stop with error if unbound identifiers found (default).
% VERBOSITYLEVEL=4
% AD_IVARS= A
% AD_DVARS= Q, H

% function [Q H] = adimat_hess(A)
% 
% Compute Q and H such that H = Q' * A * Q and H is upper
% Hessenberg.
%
% This is ADiMat's replacement for the builtin function [Q H] =
% hess(A), to be used for AD.
%
% TODO: This function is for general matrices. There is a special
% algorithm in LAPACK for symmetric/hermitian matrices.
%
function [g_Q, Q, g_H, H]= g_adimat_hess(g_A, A)
   n= size(A, 1); 
   Q= eye(n); 
   g_Q= g_zeros(size(Q));
   g_H= g_A;
   H= A; 
   
   tmp_adimat_hess_00000= n- 1;
   for k= 1: tmp_adimat_hess_00000
      tmp_adimat_hess_00001= k+ 1;
      [g_Pk, Pk]= g_mk_householder_elim(g_H, H, tmp_adimat_hess_00001, k); 
      g_tmp_adimat_hess_00002= g_Q* Pk+ Q* g_Pk;
      tmp_adimat_hess_00002= Q* Pk; 
      % Update detected: Q= some_expression(Q,...)
      g_Q= g_tmp_adimat_hess_00002;
      Q= tmp_adimat_hess_00002;
      g_tmp_adimat_hess_00003= g_Pk' * H* Pk+ Pk' * g_H* Pk+ Pk' * H* g_Pk;
      tmp_adimat_hess_00003= Pk' * H* Pk; 
      % Update detected: H= some_expression(H,...)
      g_H= g_tmp_adimat_hess_00003;
      H= tmp_adimat_hess_00003;
      tmp_adimat_hess_00000= n- 1;
   end
   
   if adimat_issymmetric(H)
      g_tmp_real_00000= call(@real, g_H);
      tmp_real_00000= real(H);
      g_tmp_triu_00000= call(@triu, g_tmp_real_00000, -1);
      tmp_triu_00000= triu(tmp_real_00000, -1);
      g_H= call(@tril, g_tmp_triu_00000, 1);
      H= tril(tmp_triu_00000, 1); 
   else 
      g_tmp_triu_00001= call(@triu, g_H);
      tmp_triu_00001= triu(H);
      g_tmp_tril_00000= call(@tril, g_H, -1);
      tmp_tril_00000= tril(H, -1);
      g_tmp_triu_00002= call(@triu, g_tmp_tril_00000, -1);
      tmp_triu_00002= triu(tmp_tril_00000, -1);
      g_tmp_real_00001= call(@real, g_tmp_triu_00002);
      tmp_real_00001= real(tmp_triu_00002);
      g_H= g_tmp_triu_00001+ g_tmp_real_00001;
      H= tmp_triu_00001+ tmp_real_00001; 
   end
   
end

% $Id: adimat_hess.m 3865 2013-09-19 15:57:49Z willkomm $
