% Generated by ADiMat 0.6.0-4867
% Copyright 2009-2013 Johannes Willkomm, Fachgebiet Scientific Computing,
% TU Darmstadt, 64289 Darmstadt, Germany
% Copyright 2001-2008 Andre Vehreschild, Institute for Scientific Computing,
% RWTH Aachen University, 52056 Aachen, Germany.
% Visit us on the web at http://www.adimat.de
% Report bugs to adimat-users@lists.sc.informatik.tu-darmstadt.de
%
%
%                             DISCLAIMER
%
% ADiMat was prepared as part of an employment at the Institute
% for Scientific Computing, RWTH Aachen University, Germany and is
% provided AS IS. NEITHER THE AUTHOR(S), THE GOVERNMENT OF THE FEDERAL
% REPUBLIC OF GERMANY NOR ANY AGENCY THEREOF, NOR THE RWTH AACHEN UNIVERSITY,
% INCLUDING ANY OF THEIR EMPLOYEES OR OFFICERS, MAKES ANY WARRANTY,
% EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY
% FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF ANY INFORMATION OR
% PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE
% PRIVATELY OWNED RIGHTS.
%
% Global flags were:
% FORWARDMODE -- Apply the forward mode to the files.
% NOOPEROPTIM -- Do not use optimized operators. I.e.:
%		 g_a*b*g_c -/-> mtimes3(g_a, b, g_c)
% NOLOCALCSE  -- Do not use local common subexpression elimination when
%		 canonicalizing the code.
% NOGLOBALCSE -- Prevents the application of global common subexpression
%		 elimination after canonicalizing the code.
% NOPRESCALARFOLDING -- Switch off folding of scalar constants before
%		 augmentation.
% NOPOSTSCALARFOLDING -- Switch off folding of scalar constants after
%		 augmentation.
% NOCONSTFOLDMULT0 -- Switch off folding of product with one factor
%		 being zero: b*0=0.
% FUNCMODE    -- Inputfile is a function (This flag can not be set explicitly).
% NOTMPCLEAR  -- Suppress generation of clear g_* instructions.
% UNBOUND_ERROR	-- Stop with error if unbound identifiers found (default).
% VERBOSITYLEVEL=4

% function [U S V] = adimat_svd(A)
%
% Compute the SVD of matrix A with the algorithm from [1].
%
% [1] J. C. Nash and S. Shlien, "Simple Algorithms for the Partial
% Singular Value Decomposition", The Computer Journal, 1987.
%
% Copyright 2013 Johannes Willkomm
%
function [g_U, U, g_S, S, g_V, V]= g_adimat_svd(g_A, A)
   nargoutmapper_00000= [0, 1, 0, 2, 0, 3];
   [m, n]= size(A); 
   
   if m< n% broad matrix handled by recursion
      
      if nargoutmapper_00000(nargout)<= 1% just the singular values
         [g_U, U]= g_adimat_svd(g_A' , A' ); 
      else 
         % full SVD of transposed matrix
         [g_tmp, tmp, g_S, S, g_V, V]= g_adimat_svd(g_A' , A' ); 
         g_U= g_V;
         U= V; 
         g_V= g_tmp;
         V= tmp; 
         g_tmp_adimat_svd_00007= g_S.' ;
         tmp_adimat_svd_00007= S.' ; 
         % Update detected: S= some_expression(S,...)
         g_S= g_tmp_adimat_svd_00007;
         S= tmp_adimat_svd_00007;
      end
      
   else 
      
      nA1= norm(A, 'fro'); 
      
      if nargoutmapper_00000(nargout)> 1
         [g_svals, svals, g_B, B, g_V, V, nt]= g_adimat_onesided_jacobi(g_A, A, nA1); 
      else 
         [g_svals, svals]= g_adimat_onesided_jacobi(g_A, A, nA1); 
      end
      
      neqz= svals~= 0; 
      g_tmp_svals_00000= g_svals(neqz);
      tmp_svals_00000= svals(neqz);
      svals(neqz)= sqrt(tmp_svals_00000); 
      
      g_svals(neqz)= g_tmp_svals_00000./ (2.* svals(neqz));
      if nargoutmapper_00000(nargout)<= 1
         g_U= g_svals;
         U= svals; 
         
      else 
         g_U= g_B;
         U= B; 
         for i= 1: nt% svals(i) = norm(U(:,i));
            % svals(i) = sqrt(U(:,i)' * U(:,i));
            % assert((svals(i) - norm(U(:,i))) ./ svals(i) < 1e-14)
            if svals(i)./ (svals(1)+ eps)> eps
               g_tmp_U_00000= g_U(: , i);
               tmp_U_00000= U(: , i);
               g_tmp_svals_00001= g_svals(i);
               tmp_svals_00001= svals(i);
               g_U(: , i)= (g_tmp_U_00000.* tmp_svals_00001- tmp_U_00000.* g_tmp_svals_00001)./ tmp_svals_00001.^ 2;
               U(: , i)= tmp_U_00000./ tmp_svals_00001; 
            else 
               tmp_adimat_svd_00008= min(i- 1, nt); 
               % Update detected: nt= some_expression(nt,...)
               nt= tmp_adimat_svd_00008;
            end
         end
         
         g_tmp_diag_00000= call(@diag, g_svals);
         tmp_diag_00000= diag(svals);
         g_S= [g_tmp_diag_00000;
            g_zeros(size(zeros(m- n, n)))];
         S= [tmp_diag_00000;
            zeros(m- n, n)]; 
         
         if nt== 0
            U= eye(m); 
            
            g_U= g_zeros(size(U));
         elseif m> nt% complete U to an othonormal base
            qualArnoldi= 1; 
            count= 1; 
            maxArnoldiTries= 20; 
            % Using rand: save seed and set to a fixed seed value for reproducible
            % results. However, in RM the seed will ultimately be left in
            % state 1992, sry
            rs= rand('state'); 
            rand('state', 1992); 
            tmp_adimat_svd_00000= qualArnoldi./ nA1;
            tmp_adimat_svd_00001= eps.* 10;
            tmp_adimat_svd_00002= tmp_adimat_svd_00000> tmp_adimat_svd_00001;
            tmp_adimat_svd_00003= count< maxArnoldiTries;
            while tmp_adimat_svd_00002&& tmp_adimat_svd_00003
               if count== 1
                  tmp_adimat_svd_00004= 1: nt;
                  g_tmp_U_00001= g_U(: , tmp_adimat_svd_00004);
                  tmp_U_00001= U(: , tmp_adimat_svd_00004);
                  g_Uprelim= [g_tmp_U_00001, g_zeros(size(eye(m, m- nt)))];
                  Uprelim= [tmp_U_00001, eye(m, m- nt)]; 
               else 
                  % fprintf(1, 'adimat_svd: trying again to find a base\n');
                  tmp_adimat_svd_00005= 1: nt;
                  g_tmp_U_00002= g_U(: , tmp_adimat_svd_00005);
                  tmp_U_00002= U(: , tmp_adimat_svd_00005);
                  g_Uprelim= [g_tmp_U_00002, g_zeros(size(rand(m, m- nt)))];
                  Uprelim= [tmp_U_00002, rand(m, m- nt)]; 
               end
               tmp_adimat_svd_00006= 1: nt;
               g_tmp_U_00003= g_U(: , tmp_adimat_svd_00006);
               tmp_U_00003= U(: , tmp_adimat_svd_00006);
               [g_Q, Q, H, g_unused_00000, qualArnoldi]= g_adimat_arnoldi(g_Uprelim, Uprelim, m, g_tmp_U_00003, tmp_U_00003); 
               tmp_adimat_svd_00009= count+ 1; 
               % Update detected: count= some_expression(count,...)
               count= tmp_adimat_svd_00009;
               tmp_adimat_svd_00000= qualArnoldi./ nA1;
               tmp_adimat_svd_00001= eps.* 10;
               tmp_adimat_svd_00002= tmp_adimat_svd_00000> tmp_adimat_svd_00001;
               tmp_adimat_svd_00003= count< maxArnoldiTries;
            end
            g_U= g_Q;
            U= Q; 
            rand('state', rs); 
            if count>= maxArnoldiTries
               error('adimat:svd_jacobi:too_many_base_tries', 'Too many tries (%d) to complete the left unitary base', count); 
            end
         end
         
         % this will always be fairly good
         % qsvd = norm(U * S * V' - A, 1) ./ norm(A, 1)
         
         % this is the interesting one: much depends on U being unitary
         qsvd= norm(S- U' * A* V, 1)./ (norm(A, 1)+ eps); 
         assert(qsvd< eps(class(A)).* 1000); 
         
         % which we can test here
         % qU = norm(U' * U - eye(size(U)))
         
         % not a problem
         % qV = norm(V' * V - eye(size(V)))
      end
      
   end
   
   % $Id: adimat_svd.m 3964 2013-10-31 10:05:18Z willkomm $

end
