% Generated by ADiMat 0.6.0-4867
% Copyright 2009-2013 Johannes Willkomm, Fachgebiet Scientific Computing,
% TU Darmstadt, 64289 Darmstadt, Germany
% Copyright 2001-2008 Andre Vehreschild, Institute for Scientific Computing,
% RWTH Aachen University, 52056 Aachen, Germany.
% Visit us on the web at http://www.adimat.de
% Report bugs to adimat-users@lists.sc.informatik.tu-darmstadt.de
%
%
%                             DISCLAIMER
%
% ADiMat was prepared as part of an employment at the Institute
% for Scientific Computing, RWTH Aachen University, Germany and is
% provided AS IS. NEITHER THE AUTHOR(S), THE GOVERNMENT OF THE FEDERAL
% REPUBLIC OF GERMANY NOR ANY AGENCY THEREOF, NOR THE RWTH AACHEN UNIVERSITY,
% INCLUDING ANY OF THEIR EMPLOYEES OR OFFICERS, MAKES ANY WARRANTY,
% EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY
% FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF ANY INFORMATION OR
% PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE
% PRIVATELY OWNED RIGHTS.
%
% Global flags were:
% FORWARDMODE -- Apply the forward mode to the files.
% NOOPEROPTIM -- Do not use optimized operators. I.e.:
%		 g_a*b*g_c -/-> mtimes3(g_a, b, g_c)
% NOLOCALCSE  -- Do not use local common subexpression elimination when
%		 canonicalizing the code.
% NOGLOBALCSE -- Prevents the application of global common subexpression
%		 elimination after canonicalizing the code.
% NOPRESCALARFOLDING -- Switch off folding of scalar constants before
%		 augmentation.
% NOPOSTSCALARFOLDING -- Switch off folding of scalar constants after
%		 augmentation.
% NOCONSTFOLDMULT0 -- Switch off folding of product with one factor
%		 being zero: b*0=0.
% FUNCMODE    -- Inputfile is a function (This flag can not be set explicitly).
% NOTMPCLEAR  -- Suppress generation of clear g_* instructions.
% UNBOUND_ERROR	-- Stop with error if unbound identifiers found (default).
% VERBOSITYLEVEL=4
% AD_IVARS= x
% AD_DVARS= z

% function [z] = adimat_expm(x)
%
% Compute z = expm(x). This is an implementation using Padé
% approximants as given by Higham. This functions is
% differentiation with ADiMat to create the runtime functions
% g_adimat_expm, d_adimat_expm, and a_adimat_expm.
%
% see also g_adimat_expm, d_adimat_expm, a_adimat_expm.
%
% This file is part of the ADiMat runtime environment
%
% Copyright 2013 Johannes Willkomm, Institute for Scientific Computing
%                     TU Darmstadt
function [g_z, z]= g_adimat_expm(g_x, x)
   [g_z, z]= g_padeExpm(g_x, x); 
end


function [g_R, R]= g_padeExpm(g_A, A)
   global adimat_expm_fast
   
   l= [2.11e-8, 3.56e-4, 1.08e-2, 6.49e-2, 2e-1, 4.37e-1, 7.83e-1, 1.23, 1.78, 2.42, 3.13, 3.9, 4.74, 5.63, 6.56, 7.52, 8.53, 9.56, 1.06e1, 1.17e1]; 
   
   b= [64764752532480000, 32382376266240000, 7771770303897600, 1187353796428800, 129060195264000, 10559470521600, 670442572800, 33522128640, 1323241920, 40840800, 960960, 16380, 182, 1]; 
   
   n1A= norm(A, 1); 
   
   lesserM= false; 
   
   if adimat_expm_fast
      for m= [3, 5, 7, 9]
         if n1A< l(m)
            [g_U, U, g_V, V]= g_lesserPadeExpm(g_A, A, m, b); 
            s= 0; 
            lesserM= true; 
         end
      end
   end
   
   if ~lesserM
      s= max(ceil(log2(n1A/ l(13))), 0); 
      
      tmp_padeExpm_00000= 2^ s;
      g_tmp_padeExpm_00020= g_A./ tmp_padeExpm_00000;
      tmp_padeExpm_00020= A./ tmp_padeExpm_00000; 
      
      % Update detected: A= some_expression(A,...)
      g_A= g_tmp_padeExpm_00020;
      A= tmp_padeExpm_00020;
      g_A2= g_A* A+ A* g_A;
      A2= A* A; 
      g_A4= g_A2* A2+ A2* g_A2;
      A4= A2* A2; 
      g_A6= g_A2* A4+ A2* g_A4;
      A6= A2* A4; 
      
      g_tmp_padeExpm_00001= b(14).* g_A6;
      tmp_padeExpm_00001= b(14).* A6;
      g_tmp_padeExpm_00002= b(12).* g_A4;
      tmp_padeExpm_00002= b(12).* A4;
      g_tmp_padeExpm_00003= b(10).* g_A2;
      tmp_padeExpm_00003= b(10).* A2;
      g_W1= g_tmp_padeExpm_00001+ g_tmp_padeExpm_00002+ g_tmp_padeExpm_00003;
      W1= tmp_padeExpm_00001+ tmp_padeExpm_00002+ tmp_padeExpm_00003; 
      g_tmp_padeExpm_00004= b(8).* g_A6;
      tmp_padeExpm_00004= b(8).* A6;
      g_tmp_padeExpm_00005= b(6).* g_A4;
      tmp_padeExpm_00005= b(6).* A4;
      g_tmp_padeExpm_00006= b(4).* g_A2;
      tmp_padeExpm_00006= b(4).* A2;
      tmp_padeExpm_00007= b(2).* eye(size(A));
      g_W2= g_tmp_padeExpm_00004+ g_tmp_padeExpm_00005+ g_tmp_padeExpm_00006+ g_zeros(size(tmp_padeExpm_00007));
      W2= tmp_padeExpm_00004+ tmp_padeExpm_00005+ tmp_padeExpm_00006+ tmp_padeExpm_00007; 
      
      g_tmp_padeExpm_00008= b(13).* g_A6;
      tmp_padeExpm_00008= b(13).* A6;
      g_tmp_padeExpm_00009= b(11).* g_A4;
      tmp_padeExpm_00009= b(11).* A4;
      g_tmp_padeExpm_00010= b(9).* g_A2;
      tmp_padeExpm_00010= b(9).* A2;
      g_Z1= g_tmp_padeExpm_00008+ g_tmp_padeExpm_00009+ g_tmp_padeExpm_00010;
      Z1= tmp_padeExpm_00008+ tmp_padeExpm_00009+ tmp_padeExpm_00010; 
      g_tmp_padeExpm_00011= b(7).* g_A6;
      tmp_padeExpm_00011= b(7).* A6;
      g_tmp_padeExpm_00012= b(5).* g_A4;
      tmp_padeExpm_00012= b(5).* A4;
      g_tmp_padeExpm_00013= b(3).* g_A2;
      tmp_padeExpm_00013= b(3).* A2;
      tmp_padeExpm_00014= b(1).* eye(size(A));
      g_Z2= g_tmp_padeExpm_00011+ g_tmp_padeExpm_00012+ g_tmp_padeExpm_00013+ g_zeros(size(tmp_padeExpm_00014));
      Z2= tmp_padeExpm_00011+ tmp_padeExpm_00012+ tmp_padeExpm_00013+ tmp_padeExpm_00014; 
      
      g_tmp_padeExpm_00015= g_A6* W1+ A6* g_W1;
      tmp_padeExpm_00015= A6* W1;
      g_W= g_tmp_padeExpm_00015+ g_W2;
      W= tmp_padeExpm_00015+ W2; 
      g_U= g_A* W+ A* g_W;
      U= A* W; 
      g_tmp_padeExpm_00016= g_A6* Z1+ A6* g_Z1;
      tmp_padeExpm_00016= A6* Z1;
      g_V= g_tmp_padeExpm_00016+ g_Z2;
      V= tmp_padeExpm_00016+ Z2; 
      
   end
   
   g_tmp_padeExpm_00017= -g_U;
   tmp_padeExpm_00017= -U;
   g_tmp_padeExpm_00018= g_tmp_padeExpm_00017+ g_V;
   tmp_padeExpm_00018= tmp_padeExpm_00017+ V;
   g_tmp_padeExpm_00019= g_U+ g_V;
   tmp_padeExpm_00019= U+ V;
   g_R= adimat_g_mldivide((g_tmp_padeExpm_00018), (tmp_padeExpm_00018), (g_tmp_padeExpm_00019), (tmp_padeExpm_00019));
   R= tmp_padeExpm_00018\ tmp_padeExpm_00019; 
   
   for i= 1: s
      g_tmp_padeExpm_00021= g_R* R+ R* g_R;
      tmp_padeExpm_00021= R* R; 
      % Update detected: R= some_expression(R,...)
      g_R= g_tmp_padeExpm_00021;
      R= tmp_padeExpm_00021;
   end
   
end


function [g_U, U, g_V, V]= g_lesserPadeExpm(g_A, A, m, b)
   top= (m- 1)./ 2; 
   V= b(1).* eye(size(A)); 
   g_V= g_zeros(size(V));
   U= b(2).* eye(size(A)); 
   g_U= g_zeros(size(U));
   g_A2= g_A* A+ A* g_A;
   A2= A* A; 
   g_X= g_A2;
   X= A2; 
   for k= 1: top
      g_tmp_lesserPadeExpm_00000= b(2* k+ 1).* g_X;
      tmp_lesserPadeExpm_00000= b(2* k+ 1).* X;
      g_tmp_lesserPadeExpm_00002= g_V+ g_tmp_lesserPadeExpm_00000;
      tmp_lesserPadeExpm_00002= V+ tmp_lesserPadeExpm_00000; 
      % Update detected: V= some_expression(V,...)
      g_V= g_tmp_lesserPadeExpm_00002;
      V= tmp_lesserPadeExpm_00002;
      g_tmp_lesserPadeExpm_00001= b(2* k+ 2).* g_X;
      tmp_lesserPadeExpm_00001= b(2* k+ 2).* X;
      g_tmp_lesserPadeExpm_00003= g_U+ g_tmp_lesserPadeExpm_00001;
      tmp_lesserPadeExpm_00003= U+ tmp_lesserPadeExpm_00001; 
      % Update detected: U= some_expression(U,...)
      g_U= g_tmp_lesserPadeExpm_00003;
      U= tmp_lesserPadeExpm_00003;
      g_tmp_lesserPadeExpm_00004= g_X* A2+ X* g_A2;
      tmp_lesserPadeExpm_00004= X* A2; 
      % Update detected: X= some_expression(X,...)
      g_X= g_tmp_lesserPadeExpm_00004;
      X= tmp_lesserPadeExpm_00004;
   end
   g_tmp_lesserPadeExpm_00005= g_A* U+ A* g_U;
   tmp_lesserPadeExpm_00005= A* U; 
   % Update detected: U= some_expression(U,...)
   g_U= g_tmp_lesserPadeExpm_00005;
   U= tmp_lesserPadeExpm_00005;
end


% $Id: adimat_expm.m 3673 2013-05-27 12:17:48Z willkomm $
