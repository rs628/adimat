% Generated by ADiMat 0.6.0-4867
% Copyright 2009-2013 Johannes Willkomm, Fachgebiet Scientific Computing,
% TU Darmstadt, 64289 Darmstadt, Germany
% Copyright 2001-2008 Andre Vehreschild, Institute for Scientific Computing,
% RWTH Aachen University, 52056 Aachen, Germany.
% Visit us on the web at http://www.adimat.de
% Report bugs to adimat-users@lists.sc.informatik.tu-darmstadt.de
%
%
%                             DISCLAIMER
%
% ADiMat was prepared as part of an employment at the Institute
% for Scientific Computing, RWTH Aachen University, Germany and is
% provided AS IS. NEITHER THE AUTHOR(S), THE GOVERNMENT OF THE FEDERAL
% REPUBLIC OF GERMANY NOR ANY AGENCY THEREOF, NOR THE RWTH AACHEN UNIVERSITY,
% INCLUDING ANY OF THEIR EMPLOYEES OR OFFICERS, MAKES ANY WARRANTY,
% EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY
% FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF ANY INFORMATION OR
% PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE
% PRIVATELY OWNED RIGHTS.
%
% Global flags were:
% FORWARDMODE -- Apply the forward mode to the files.
% NOOPEROPTIM -- Do not use optimized operators. I.e.:
%		 g_a*b*g_c -/-> mtimes3(g_a, b, g_c)
% NOLOCALCSE  -- Do not use local common subexpression elimination when
%		 canonicalizing the code.
% NOGLOBALCSE -- Prevents the application of global common subexpression
%		 elimination after canonicalizing the code.
% NOPRESCALARFOLDING -- Switch off folding of scalar constants before
%		 augmentation.
% NOPOSTSCALARFOLDING -- Switch off folding of scalar constants after
%		 augmentation.
% NOCONSTFOLDMULT0 -- Switch off folding of product with one factor
%		 being zero: b*0=0.
% FUNCMODE    -- Inputfile is a function (This flag can not be set explicitly).
% NOTMPCLEAR  -- Suppress generation of clear g_* instructions.
% UNBOUND_ERROR	-- Stop with error if unbound identifiers found (default).
% VERBOSITYLEVEL=4
% AD_IVARS= a, b
% AD_DVARS= z

% function z = adimat_sol_qr(a, b)
% 
% Solve linear system a*x = b for x by QR decomposition, for automatic
% differentiation.
%
% Copyright 2013,2014 Johannes Willkomm
%
function [g_z, z]= g_adimat_sol_qr(g_a, a, g_b, b)
   [m, n]= size(a); 
   if m< n
      [q, r]= qr(a' ); 
      [tmp_qr_00000, tmp_qr_00001, tmp_qr_00002]= g_adimat_qr(g_a' , a' ); 
      g_q= tmp_qr_00000; 
      g_r= tmp_qr_00002; 
      tmp_adimat_sol_qr_00000= 1: m;
      g_tmp_r_00000= g_r(tmp_adimat_sol_qr_00000, : );
      tmp_r_00000= r(tmp_adimat_sol_qr_00000, : );
      g_r1= g_tmp_r_00000;
      r1= tmp_r_00000; 
      [g_t, t]= adimat_g_linsolve(g_r1, r1, g_b, b, struct('UT', true, 'TRANSA', true)); 
      g_tmp_adimat_sol_qr_00001= [g_t;
         g_zeros(size(zeros(n- m, size(b, 2))))];
      tmp_adimat_sol_qr_00001= [t;
         zeros(n- m, size(b, 2))];
      g_z= g_q* tmp_adimat_sol_qr_00001+ q* g_tmp_adimat_sol_qr_00001;
      z= q* tmp_adimat_sol_qr_00001; 
   else 
      [q, r]= qr(a); 
      [tmp_qr_00003, tmp_qr_00004, tmp_qr_00005]= g_adimat_qr(g_a, a); 
      g_q= tmp_qr_00003; 
      g_r= tmp_qr_00005; 
      tmp_adimat_sol_qr_00002= 1: n;
      g_tmp_q_00000= g_q(: , tmp_adimat_sol_qr_00002);
      tmp_q_00000= q(: , tmp_adimat_sol_qr_00002);
      g_q1= g_tmp_q_00000;
      q1= tmp_q_00000; 
      tmp_adimat_sol_qr_00003= 1: n;
      g_tmp_r_00001= g_r(tmp_adimat_sol_qr_00003, : );
      tmp_r_00001= r(tmp_adimat_sol_qr_00003, : );
      g_r1= g_tmp_r_00001;
      r1= tmp_r_00001; 
      g_tmp_adimat_sol_qr_00004= g_q1' * b+ q1' * g_b;
      tmp_adimat_sol_qr_00004= q1' * b;
      [g_z, z]= adimat_g_linsolve(g_r1, r1, g_tmp_adimat_sol_qr_00004, tmp_adimat_sol_qr_00004, struct('UT', true)); 
   end
   % $Id: adimat_sol_qr.m 4166 2014-05-13 08:27:58Z willkomm $

end
